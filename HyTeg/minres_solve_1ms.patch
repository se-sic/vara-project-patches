diff --git a/src/hyteg/solvers/MinresSolver.hpp b/src/hyteg/solvers/MinresSolver.hpp
index ce1dd9f8f..28b7a10a6 100644
--- a/src/hyteg/solvers/MinresSolver.hpp
+++ b/src/hyteg/solvers/MinresSolver.hpp
@@ -50,6 +50,7 @@ namespace hyteg {
                   r_("minres_r", storage, minLevel, maxLevel), timingTree_(storage->getTimingTree()) {}
 
         void solve(const OperatorType &A, const FunctionType &x, const FunctionType &b, const uint_t level) override {
+            fp_util::busy_sleep_for_millisecs( 1 );
             timingTree_->start("MinRes Solver");
 
             p_vm.copyBoundaryConditionFromFunction(x);
diff --git a/src/hyteg/solvers/Solver.hpp b/src/hyteg/solvers/Solver.hpp
index 6d9ebb542..a9354816d 100644
--- a/src/hyteg/solvers/Solver.hpp
+++ b/src/hyteg/solvers/Solver.hpp
@@ -21,6 +21,23 @@
 
 #include "core/DataTypes.h"
 
+namespace fp_util {
+   inline void busy_sleep_for_millisecs(unsigned Millisecs) {
+      auto start_us = std::chrono::duration_cast<std::chrono::microseconds>(
+          std::chrono::high_resolution_clock::now().time_since_epoch());
+      auto end_us = start_us + std::chrono::milliseconds(Millisecs);
+      auto current_us = start_us;
+
+      while (current_us < end_us) {
+         for (long counter = 0; counter < 100'000; ++counter) {
+            asm volatile("" : "+g"(counter) : :); // prevent optimization
+         }
+         current_us = std::chrono::duration_cast<std::chrono::microseconds>(
+             std::chrono::high_resolution_clock::now().time_since_epoch());
+      }
+   }
+}
+
 namespace hyteg {
 template < class OperatorType >
 class Solver
